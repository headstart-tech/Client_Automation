"""
Communication summary Header data helper.
"""
from app.database.configuration import DatabaseConfiguration
from app.core.utils import utility_obj
from bson.objectid import ObjectId
from datetime import date


class CommunicationHeader:
    """
    All related functions of communication summary header API.
    """

    async def count_helper(self, date_range: dict, event_type: str, summary_field: str, template_id=None, counselor_id=None) -> dict:
        """
        General helper function to count communication events (email, WhatsApp, SMS) generated by the system.

        Params:
            date_range (dict): Date range for filtration
            event_type (str): Type of event to count ('email', 'whatsapp', 'sms')
            collection (str): Collection name to query
            summary_field (str): Summary field to check for existence
            template_id: If we want to filter count of communication according to template_id. By default, it should be None.
            counselor_id(list) : To filter the data based on counselors

        Returns:
            dict: Count of communication events
        """
        match_stage = {
            'timeline.event_type': event_type
        }
        cond = {}
        automation_match_stage = {
            f'{summary_field}_summary': {
                '$exists': True
            }
        }
        pipeline = []
        automation_pipeline = []

        # TODO: template_id is not stored in the db communication summary collection. So currently we can't fetch any template specific communication data.
        if template_id:
            match_stage['timeline.template_id'] = template_id
            automation_match_stage['timeline.template_id'] = template_id

        if date_range:
            start_date, end_date = await utility_obj.date_change_format(
                date_range.get('start_date'),
                date_range.get('end_date')
            )

            date = {"$gte": start_date, "$lte": end_date}

            match_stage["timeline.timestamp"] = date
            automation_match_stage["timeline.timestamp"] = date

            cond["$and"] = [
                {"$gte": ["$$item.timestamp", start_date]},
                {"$lte": ["$$item.timestamp", end_date]}
            ]

        if counselor_id:
            students = await DatabaseConfiguration().studentsPrimaryDetails.aggregate(
                [
                    {
                        "$match": {
                            "allocate_to_counselor.counselor_id": {"$in": counselor_id}
                        }
                    },
                    {
                        "$group": {
                            "_id": None,
                            "student_ids": {"$push": "$_id"}
                        }
                    },
                    {
                        "$project": {
                            "_id": 0
                        }
                    }
                ]
            ).to_list(None)
            student_ids = students[0].get("student_ids") if students else []
            match_stage['student_id'] = {'$in': student_ids}
            automation_match_stage['student_id'] = {'$in': student_ids}

        pipeline.append({"$match": match_stage})
        automation_pipeline.append({"$match": automation_match_stage})

        common_stages = [
            {
                '$project': {
                    'timeline': {
                        '$filter': {
                            'input': '$timeline',
                            'as': 'item',
                            'cond': cond
                        }
                    }
                }
            },
            {
                '$project': {
                    'timelineCount': {
                        '$size': '$timeline'
                    }
                }
            },
            {
                '$group': {
                    '_id': None,
                    'totalCount': {
                        '$sum': '$timelineCount'
                    }
                }
            }
        ]

        pipeline.extend(common_stages)
        automation_pipeline.extend(common_stages)

        data = await DatabaseConfiguration().communication_log_collection.aggregate(pipeline).to_list(None)
        automation_data = await DatabaseConfiguration().automation_communicationLog_details.aggregate(automation_pipeline).to_list(None)

        data = data[0] if data else {}
        automation_data = automation_data[0] if automation_data else {}

        total_count = data.get("totalCount", 0)
        total_automation_count = automation_data.get("totalCount", 0)

        return {
            f"total_{event_type}": total_count,
            f"{event_type}_type": {
                "automated": total_automation_count,
                "manual": total_count - total_automation_count
            }
        }
    

    async def communication_header_helper(self, date_range: dict, counselor_id:list = None) -> dict:
        """
        Communication summary details count and calculation

        Params:
            date_range (dict): Date range for date filtration
            counselor_id (list) : list of counselors ids to filter data

        Returns:
            dict: Data summary of communications
        """

        email = await self.count_helper(date_range, "email", "email", counselor_id=counselor_id)
        whatsapp = await self.count_helper(date_range, "whatsapp", "whatsapp", counselor_id=counselor_id)
        sms = await self.count_helper(date_range, "sms", "sms", counselor_id=counselor_id)

        total_communication = email.get("total_email") + whatsapp.get("total_whatsapp") + sms.get("total_sms")
        
        return {
            "email": email,
            "whatsapp": whatsapp,
            "sms": sms,
            "total_communication": total_communication
        }


    async def header_helper(self, date_range: dict, change_indicator: str, counselor_id:list=None) -> dict:
        """
        Communication header data retrieved from database and formatted in proper dictionary

        Params:
            date_range (dict): Contains start_date and end_date dictionary
            change_indicator (str): For comparison between current and past date data differences
            counselor_id (list) : list of counselors ids to filter data

        Returns:
            dict: Result of data in the form of dictionary
        """
        data = await self.communication_header_helper(date_range, counselor_id)

        start_date, middle_date, previous_date = await utility_obj. \
                get_start_date_and_end_date_by_change_indicator(change_indicator)

        previous_date_data = await self.communication_header_helper(date_range={"start_date": str(start_date),
                    "end_date": str(middle_date)}, counselor_id=counselor_id)
        current_date_data = await self.communication_header_helper(date_range={"start_date": str(previous_date),
                    "end_date": str(date.today())}, counselor_id=counselor_id)
        
        total_communication_change_indicator = await utility_obj.get_percentage_difference_with_position(previous_date_data.get("total_communication", 0), current_date_data.get("total_communication", 0))

        data.update({
            "total_communication_change_indicator": {
                "total_communication_perc_indicator": total_communication_change_indicator.get("percentage", 0),
                "total_communication_pos_indicator": total_communication_change_indicator.get("position", "equal")
            }
        })

        return data
